<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link sizes="32x32" rel="icon" type="image/ico" href="ico.ico">
    <title>Shifro</title>
</head>
<body>
    <style>
#auth button,#dataSave #secure,#dataSave .btnGroup .secureLabel,.addbtn,.del,.fileblock,.menu li,.showhide,.showtags,.spoiler,.tag li{cursor:pointer}body,h1{margin:0}.addbtn,.password{border-radius:5px}.menu,.tag{list-style:none}.menu:hover li,.tag li,.tag:hover li{color:#bdbdbd}@font-face{font-family:InterReg;font-style:normal;font-weight:400;src:url('font/inter-regular-webfont.woff2') format('woff2'),url('font/inter-regular-webfont.ttf') format('truetype')}@font-face{font-family:InterMed;font-style:normal;font-weight:400;src:url('font/inter-medium-webfont.woff2') format('woff2'),url('font/inter-medium-webfont.ttf') format('truetype')}@font-face{font-family:InterBold;font-style:normal;font-weight:400;src:url('font/inter-bold-webfont.woff2') format('woff2'),url('font/inter-bold-webfont.ttf') format('truetype')}body{font:14px InterReg,sans-serif}b,h1,h2,h3,h4{font-weight:400;font-family:InterBold,sans-serif}.none{display:none!important}#auth,.ifauth{display:none}.unone{user-select:none}.wrap{width:600px;margin:0 auto}#dataSave,.bottom,.fileblock,.header,.logo,.menu,.tag{display:flex}.logo{align-items:center}.logo svg{width:70px;margin-right:15px}h1{font:72px InterBold;letter-spacing:-.07em}.addbtn{padding:20px 0 20px 20px;font:24px InterReg;margin:13px 0 0}.header{align-items:center;justify-content:space-between;margin:30px 0 10px}#auth{margin:30px 0;justify-content:space-between;gap:20px}.password{width:100%;height:50px;padding:0 0 0 15px;border:1px solid #a3a3a3;font:18px InterReg,sans-serif}#auth button{width:140px;font-size:18px;border:none;border-radius:5px;background:#e3e3e3}.menu{padding:0;margin:0 0 15px;flex-wrap:wrap;gap:15px;font:22px InterReg;pointer-events:none;max-height:95px;overflow:hidden}.bottom,.spoiler{font:18px InterReg}.menu li{pointer-events:auto;padding:20px 0;line-height:0}.menu li:hover,.tag li:hover{color:#000}#dataSave{flex-wrap:wrap;justify-content:space-between;margin:20px 0}#dataSave .btnFile,#dataSave .btnGroup button{box-sizing:border-box;font:18px/50px InterReg;margin-right:15px;cursor:pointer}#dataSave textarea{height:150px;padding:15px;border-radius:5px;border:1px solid #a3a3a3;font:18px InterReg,sans-serif}#dataSave *{width:100%;margin-bottom:15px}#dataSave .btnGroup{display:flex;align-items:center;flex-wrap:wrap}#dataSave #secure{width:20px}#dataSave .btnGroup .secureLabel{font:16px InterReg,sans-serif;padding:15px 0 15px 5px;flex:1}#dataSave .btnGroup button{width:200px;height:50px;border:none;border-radius:5px;background:#e3e3e3}#dataSave input{height:50px;padding:0 0 0 15px;border-radius:5px;border:1px solid #a3a3a3;font:18px InterReg,sans-serif}#dataSave .btnFile{width:85px;border:1px solid #a3a3a3;height:50px;border-radius:5px;text-align:center;display:inline-block}#dataSave .inputFile{width:.1px;height:.1px;opacity:0;overflow:hidden;position:absolute;z-index:-1}.block:hover .del{opacity:1}#wrapContent h3{font:32px InterBold;margin:0 0 25px}.block{margin-bottom:50px}#wrapContent p{font:22px/28px InterReg}.tag{flex-wrap:wrap;grid-gap:20px;margin:0;padding:0}.bottom{align-items:center;justify-content:space-between}.del{opacity:0;transition:opacity .15s}.spoiler{border-bottom:1px solid #333}.showhide{color:#239aff;border-bottom:1px solid #239aff}.progress{height:5px;background:#000;top:-5px;position:fixed;max-width:100%;width:100%;transition:.15s}.imagepreview,.shadow{position:fixed;top:0;bottom:0;right:0;left:0}.fileblock svg{width:25px;margin:0 5px 0 15px}.fileblock{height:65px;margin-bottom:5px;border:1px solid #c4c4c4;align-items:center;text-decoration:none;color:#000;border-radius:10px}.fileblock div{display:block;font:14px InterReg}.fileblock span{display:block;font:12px InterReg;opacity:.6}.imagepreview{max-width:80%;max-height:80%;width:auto;height:auto;margin:auto;z-index:5}.shadow{background:rgb(0 0 0 / 60%);width:100%;height:100%;z-index:1}.showtags{font-size:24px;color:#239aff;border-bottom:1px solid #239aff}#wrapContent{margin-top:50px}@media (max-width:620px){#dataSave .btnGroup button,#dataSave input,#dataSave textarea{border-radius:2vw;font-size:5.5vw}.wrap{width:90vw}.header{margin:5vw 0 3vw}h1{font-size:15vw}.addbtn{margin:0;font-size:6vw;padding:5vw 0 5vw 5vw}.bottom,.menu,.spoiler{font-size:4.5vw}.dataSave{margin:5vw 0 0}#dataSave input{height:14vw;padding:0 0 0 4vw}#dataSave *{margin-bottom:3vw}#dataSave textarea{height:30vw;padding:4vw}#dataSave .btnGroup button{order:4;width:100%;margin-right:0;height:15vw;line-height:normal}#dataSave .btnFile{order:3;width:40vw;margin:0;height:15vw;line-height:15vw;font-size:6vw}#dataSave .btnGroup{justify-content:space-between;align-items:stretch}#dataSave #secure{order:1;width:7vw;padding:3vw;margin:1vw 0 0 4vw}#dataSave .btnGroup .secureLabel{order:2;width:35vw;display:block;flex:none;padding:2vw 0 2vw 2vw;font-size:4.5vw}.menu li{pointer-events:auto;padding:6vw 0}.menu{column-gap:6vw;padding:0;row-gap:0;max-height:24vw;overflow:hidden;margin:0 0 3vw}#wrapContent{margin-top:10vw}.block{margin-bottom:10vw}#wrapContent h3{font-size:6.5vw;margin:0 0 5vw}#wrapContent p{margin:0 0 5vw;font:6vw/8vw InterReg}.fileblock{height:20vw;margin-bottom:2vw;border-radius:3vw}#auth button,.password{height:15vw;border-radius:2vw}.fileblock svg{width:6vw;margin:0 2vw 0 4vw}.fileblock div{font-size:4.5vw}.fileblock span{font-size:4vw}#auth button,.password,.showtags{font-size:6vw}.password{padding:0 0 0 4vw;margin-bottom:3vw}#auth button{width:100%}#auth{display:flex;gap:0;flex-wrap:wrap}}
  </style>
  <div class="progress"><div class="progresstext"></div><div class="progressline"></div></div>
  <div class="wrap">
    <div class="header">
     <div class="logo">
       <h1 class="unone">Shifro v2</h1>
     </div>      
      <div class="addbtn unone ifauth">добавить +</div>
    </div>
    <form id="auth">
        <input type="password" class="password" name="password" placeholder="пароль" readonly
    onfocus="this.removeAttribute('readonly')"><button class="unone">войти</button>
    </form>
    <form id="dataSave" class="none dataSave">
      <input type="text" id="title" name="title" placeholder="заголовок" autocomplete="off" readonly onfocus="this.removeAttribute('readonly')">
      <textarea id="content" name="content" placeholder="текст
#тег #тег2"></textarea>
            <div class="btnGroup">
                <button type="submit" class="unone">сохранить</button>
                <label for="inputFile" class="btnFile unone">файл</label>
                <input type="file" class="inputFile" id="inputFile" name="file" multiple onchange="inputJs(this)">
                <input type="checkbox" name="secure" id="secure">
                <label for="secure" class="unone secureLabel">скрытые данные</label>
            </div>
        </form>
    <div class="ifauth wrapcont">
        <ul class="menu unone" onclick="handleTag(event)">
            <li>всё</li>
        </ul>
        <div id="wrapContent"></div>
    </div>
  </div>
</body>
</html>
<script>
const user = "shifro";
const rep = "shifro";
const giturl = `https://api.github.com/repos/${user}/${rep}/contents/`;
const dbfile = 'database.txt';
const dburl = giturl + dbfile;
let password, encryptdb, jsonara, token, sha, id;
let maxfilesize = 0;
let wc = q(".console .wrap");
function cl(e) {
  console.log(e);
}

function formatValue(value) {
  if (typeof value === 'string') {
    // Если значение - строка, и она превышает 30 символов, обрезаем её
    if (value.length > 100) {
      return value.slice(0, 100) + '...';
    }
  } else if (Array.isArray(value)) {
    // Если значение - массив, рекурсивно обрабатываем его элементы
    return value.map(formatValue);
  } else if (typeof value === 'object') {
    // Если значение - объект, рекурсивно обрабатываем его свойства
    const formattedObject = {};
    for (const key in value) {
      formattedObject[key] = formatValue(value[key]);
    }
    return formattedObject;
  }
  // Если значение не требует обрезки, возвращаем его как есть
  return value;
}


function q(e) {return document.querySelector(e);}
function qq(e) {return document.querySelectorAll(e);}
function escapeHTML(e) {return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, "<br>");}
function formatFileSize(e) {return e >= 1048576 ? (e / 1048576).toFixed(2) + " мб" : e >= 1024 ? (e / 1024).toFixed(2) + " кб" : e + " байт";}
function wrapLinksInAnchorTags(e) {return e.replace(/\S+\.\S+/g, (e) => `<a href="//${e}" target="_blank">${e}</a>`);}
function inputJs(e) {"" != e.value ? (e.previousElementSibling.innerHTML = `+ ${e.files.length}`) : (e.previousElementSibling.innerHTML = "файл");e.files;}

async function getFile(id, fileid) {
  let data = jsonara.data[id];
  let decryptchunk;
  let fileChunks = [];
  

  // получаем массив данных
  let getfromgit = await req("GET", data.files[fileid].url, data.files[fileid].size);

  let acb64 = JSON.parse(atob(getfromgit.content));
  

  for (var i = 0; i < acb64.length; i++) {
      let decryptchunk = await decrypt(acb64[i]);
      fileChunks.push(decryptchunk);
  }

  let compfile = fileChunks.join('');
  if (data.files[fileid].type.includes('image')) {
    q("body").insertAdjacentHTML("afterbegin", `<div class="shadow" onclick="this.remove();"><img src="${compfile}" class="imagepreview"></div>`);
  } else {
    base2file(data.files[fileid].name, fileChunks.join(''));
  }




}
// вывод записей
function viewContent(e, t = 1) {
  let a = jsonara.data.length;
  e.forEach(function (e, n) {
    if (e) {
      // перебираем файлы
      let r = viewfile = "";
      if (e.files && e.files.length > 0) {
        e.files.forEach(function (file, nfile) {
          //let imgholder = file.type.includes('image') ?  : `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="48" height="48"><path d="M12.5 4C10.03 4 8 6.03 8 8.5v31c0 2.47 2.03 4.5 4.5 4.5h23c2.47 0 4.5-2.03 4.5-4.5v-21a1.5 1.5 0 0 0-.44-1.06l-.015-.016L26.56 4.439A1.5 1.5 0 0 0 25.5 4h-13zm0 3H24v8.5c0 2.47 2.03 4.5 4.5 4.5H37v19.5c0 .847-.653 1.5-1.5 1.5h-23c-.846 0-1.5-.653-1.5-1.5v-31c0-.846.654-1.5 1.5-1.5zM27 9.12l7.879 7.88h-6.38c-.846 0-1.5-.654-1.5-1.5V9.12z"/></svg>`;

          viewfile += `<div class="fileblock" onclick="getFile(${a - n - 1},${nfile})"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48"><defs><style>.a{fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;}</style></defs><path class="a" d="M39.5,15.5h-9a2,2,0,0,1-2-2v-9h-18a2,2,0,0,0-2,2v35a2,2,0,0,0,2,2h27a2,2,0,0,0,2-2Z"></path><line class="a" x1="28.5" y1="4.5" x2="39.5" y2="15.5"></line></svg><div>${file.name}<span>${formatFileSize(file.size)}</span></div></div>`
        });

      }
      // перебираем теги
      if (e.tags.length > 0) {
        e.tags.forEach(function (e) {
          r += `<li>${e}</li>`;
        });
      }
      let s = `<div class="block" id="rec${a - n - 1}">\n<h3>${e.title}</h3>\n
      <p>${
                e.content.length > 300
                    ? e.content.substring(0, 300) + "... <span class='showhide unone' onclick='spoilerBlock(this)'>показать запись</span>"
                    : e.hasOwnProperty("secure")
                    ? "<span class='showhide unone' onclick='spoilerBlock(this)'> показать запись</span>"
                    : e.content
      }</p>\n
      ${viewfile}\n<div class="bottom">\n<ul class="tag unone" onclick="handleTag(event)">${r}</ul>\n<span class="del unone" onclick="removeBlock(this)">удалить</span>\n</div>\n</div>`;
      whereinsert = t === 1 ? 'beforeend' : 'afterbegin';
      q("#wrapContent").insertAdjacentHTML(whereinsert, s);
    }
  });
}


// API запрос
function req(e, t, n = false) {
  cl({"Отправка запроса":{e,t,n}});
  return new Promise(function (a, r) {
    var s = new XMLHttpRequest;
    s.open(e, t, true);
    if (token) {
      s.setRequestHeader("Authorization", `token ${token}`);
    }
    s.setRequestHeader("Content-Type", "application/json");
    s.upload.onprogress = function (e) {
      loadanim(e.loaded / e.total * 100);
    };
    if (e === "GET" && n) {
      s.onprogress = e => {
        cl("Получение данных");
        loadanim(e.loaded / n * 73);
      };
    }
    s.onload = () => {
      cl({'API запрос выполнен':JSON.parse(s.response)});
      loadanim()
      if (s.status >= 200 && s.status < 300) {
        a(JSON.parse(s.response));
      } else {
        r(s.status);
      }
    };
    s.onerror = function () {
      r(s.statusText);
      loadanim();
    };
    if (e === "PUT" || e === "DELETE") {
      s.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
      s.send(JSON.stringify(n));
    } else {
      s.send();
    }
  });
}

// первая загрузка
document.addEventListener("DOMContentLoaded", async () => {
  try {
    let e = await req("GET", dburl + "?r=" + Math.random());
    if (!(e.content.length > 0)) {
      e = await req("GET", e.git_url, e.size);
    }

    if (e.content) {
      encryptdb = atob(e.content);
      sha = e.sha;
      q("#auth").style.display = "flex";
    } else {
      throw('Контента нет');
    }
    
  } catch (error) {
    cl({"catch DOMContentLoaded": error});
    alert(`Не удалось получить БД. Ошибка ${e}`);
  }
});

function readFileAsync(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = function () {
            resolve({
                "name": file.name,
                "type": file.type,
                "size": file.size,
                "data": reader.result
            });
        };
    });
}

// сохранение
q("#dataSave").addEventListener("submit", async function (e) {
  e.preventDefault();
  const inputFile = document.getElementById("inputFile");
  const files = inputJs(inputFile);
  try {
    // объявляем объект
    let t = {};
    // назначем id
    id = jsonara.data.length;

    // указываем время
    timestamp = (new Date).toLocaleString();
    t.time = timestamp;

    // перебор formdata
    const n = new FormData(this);
    for (let [e, a] of n.entries()) {
      if (e !== "file") {
        t[e] = a;
      } else {
        maxfilesize = a.size > maxfilesize ? a.size : maxfilesize;
      }
    }

    // валидация
    if (t.title.length < 1) {
      throw("укажи заголовок");
    }
    if (t.content.length < 1) {
      throw("укажи данные");
    }

    // вытаскиваем хештеги
    let a = /#[^\s#]+/g;
    let r = t.content.match(a);
    let s = [];
    if (r) {
      for (var o = 0; o < r.length; o++) {
        var i = r[o].substring(1);
        s.push(i);
      }
      t.tags = s;
    } else {
      t.tags = ["безтега"];
    }
  
    // обработка текста
    t.content = escapeHTML(t.content.trim().replace(a, ""));
    t.content = wrapLinksInAnchorTags(t.content);

    // работа с файлами
    let inputFiles = q("#inputFile");
    console.dir(inputFiles.files);
    if (inputFiles.files.length > 0) {
      try {
        let arafiles = await cryptoFiles(inputFiles.files);
        t.files = arafiles;
      } catch (fileError) {
        cl({'catch в форме во время шифровании файлов':fileError});
        throw(fileError);
      }
    }

    // заполняем данные
    jsonara.data[id] = t;
  
    // формируем теги
    t.tags.forEach(function (e) {
      if (!jsonara.tags[e]) {
        jsonara.tags[e] = [];
        q(".menu").insertAdjacentHTML("afterbegin", `<li>${e}</li>`);
        if (q(".menu").clientHeight < q(".menu").scrollHeight) {
          q(".menu").insertAdjacentHTML("afterend", `<a class="showtags" onclick="showtags(this)">все теги</a>`);
        }
      }
      jsonara.tags[e].push(id);
    });
  
    // отправка
    cl({"Массив с данными подготовлен": jsonara});
    const encryara = await encrypt(JSON.stringify(jsonara));
    updategit(encryara).then(u => {
      cl(`Данные успешно добавлены`);
      e.target.reset(); inputFiles.onchange();
      return viewContent([t], 2);
    }).catch(err => {
      cl({'catch в форме во время updategit':err});
      throw(err);
    });

  } catch (error) {
    alert(`Ошибка при сохранении. ${error}`)
    cl({'catch в конце формы':error});
  }
    
});

async function cryptoFiles(files) {
  try {
    const encryptedFiles = [];
    const lca = await limitCryptoApi(maxfilesize);
    const chunkSize = lca;

    // цикл
    cl(`Всего файлов ${files.length}`);
    for (let i = 0; i < files.length; i++) {
      const fileChunks = [];
      let offset = 0;

      cl(`Чтение файла: ${i+1}`);
      let filedata = await readFileAsync(files[i]);

      cl(`Шифрование файла`);
      while (offset < filedata.data.length) {
          let chunk = filedata.data.slice(offset, offset + chunkSize);
          let encryptedChunk = await encrypt(chunk);
          fileChunks.push(encryptedChunk);
          offset += chunkSize;
          loadanim(offset / filedata.data.length * 100);
      }
      loadanim();
      cl(`Файл зашифрован`);

      let uploadflie = await updategit(JSON.stringify(fileChunks),`${id}_${i}.shfro`);
      cl({'Файл отправлен':uploadflie});
      //throw('bitch');
      encryptedFiles.push({
        "name": filedata.name,
        "type": filedata.type,
        "size": filedata.size,
        "sha": uploadflie.content.sha,
        "url": uploadflie.content.git_url
      });

    }
    cl(`Все файлы обработаны`);
    return encryptedFiles;
  } catch (error) {
    cl({'Catch в cryptoFiles':error});
    throw(error);
  }
}

// функция сохранения
async function updategit(e, file = 'db') {
  try {
    // шифрование
    let n = {message: "shifro", content: btoa(unescape(encodeURIComponent(e))), sha: sha};

    // определение url
    url = file === 'db' ? dburl : `${giturl}files/${file}`;
    // запрос
    const a = await req("PUT", url, n);
    // выдача sha
    if (file === 'db') sha = a.content.sha;

    return a;
  } catch (error) {
    cl({'Catch в updategit':error});
    throw e;
  }
}

// удаление блока
async function removeBlock(e) {
  cl("Удаление записи");
  let t = e.closest(".block").id;
  let n = Number(t.replace(/\D+/g, ""));
  let a = [];
  let r = jsonara.data[n].tags;

  // удаление файла с git
  if (jsonara.data[n].files) {
    for (var i = 0; i < jsonara.data[n].files.length; i++) {
      await req("DELETE", `${giturl}files/${n}_${i}.shfro`, {message: "shifro", sha: jsonara.data[n].files[i].sha});
    }
  }
  

  // Удаление тегов
  for (let e of r) {
    jsonara.tags[e] = jsonara.tags[e].filter(e => e !== n);
    if (jsonara.tags[e].length === 0) {
      a.push(e);
      delete jsonara.tags[e];
    }
  }

  // удаление записи из массива
  delete jsonara.data[n];

  // сохранение обновлённой информации на git
  const encryara = await encrypt(JSON.stringify(jsonara));
  updategit(encryara).then(e => {
    q("#" + t).remove();
    if (a.length > 0) {
      q(".menu").querySelectorAll("li").forEach(e => {
        if (a.includes(e.textContent)) {
          e.remove();
        }
      });
    }
  }).catch(error => {
    cl({'Catch в removeblock':error});
    alert(`ошибка при удалении объекта: ${error}`);
  });
  cl("запись удалена");
}

// отображение записей по тегу
function handleTag(e) {
  if (e.target.nodeName === "LI") {
    targetTag = e.target.innerText;
    q("#wrapContent").innerHTML = "";
    if (targetTag === "всё") {
      jsonara.data.reverse();
      viewContent(jsonara.data);
      jsonara.data.reverse();
    } else {
      newArray = jsonara.tags[targetTag].map(e => jsonara.data[e]);
      viewContent(newArray.reverse());
    }
  }
}

// скрытие и отображение статьи
function spoilerBlock(e, t = true) {
  let n = e.closest(".block");
  let a = n.id;
  let r = Number(a.replace(/\D+/g, ""));
  n.querySelector("p").innerHTML = t === true ? jsonara.data[r].content + "<br><span class='showhide unone' onclick='spoilerBlock(this, false)'>скрыть запись</span>" : "<span class='showhide unone' onclick='spoilerBlock(this)'>показать запись</span>";
}

// авторизация
q("#auth").addEventListener("submit", async function (e) {
  e.preventDefault();
  password = e.target.elements.password.value;
  decrypt(encryptdb, password).then(e => {
    jsonara = JSON.parse(e);
    qq(".ifauth").forEach(function (e) {
      e.classList.remove("ifauth");
    });
    Object.keys(jsonara.tags).forEach(e => {
      q(".menu").insertAdjacentHTML("afterbegin", `<li>${e}</li>`);
    });
    if (q(".menu").clientHeight < q(".menu").scrollHeight) {
      q(".menu").insertAdjacentHTML("afterend", `<a class="showtags" onclick="showtags()">все теги</a>`);
    }
    jsonara.data.reverse();
    viewContent(jsonara.data);
    jsonara.data.reverse();
    q("#auth").classList.add("none");
    token = jsonara.token;
    cl({'Успешная авторизация':jsonara});
  }).catch(error => {
    cl({'Catch в #auth':error});
    alert("Неверный пароль");
  });
});

// отображение формы записи
q(".addbtn").addEventListener("click", (e) => q("#dataSave").classList.toggle("none"));

// анимация прогресса
let psdiv = q(".progress");
function loadanim(e = false) {
  if (e !== false) {
    psdiv.style.top = "0px";
    psdiv.style.width = e + "%";
  } else {
    psdiv.style.top = "-5px";
  }
}

// вывод всех тегов
function showtags() {
  q(".menu").style.height = "auto";
  q(".wrapcont").removeChild(q(".showtags"));
}


//криптография
async function encrypt(t,e=password) {
  try {
     const n = (new TextEncoder).encode(t);
    const a = crypto.getRandomValues(new Uint8Array(12));
    const r = crypto.getRandomValues(new Uint8Array(16));
    const s = await genAES(e, r);
    const o = await crypto.subtle.encrypt({name: "AES-GCM", iv: a}, s, n);
    const i = new Uint8Array(28 + o.byteLength);
    i.set(r);
    i.set(a, 16);
    i.set(new Uint8Array(o), 28);
    return btoa(String.fromCharCode(...i));
  } catch (error) {
    cl({'Catch в encrypt':error});
    throw(error);
  }
 
}

/*async function encrypt(password = 123, plaintext) {
  cl('Начало шифрования');
  try {
    const encoder = new TextEncoder();
    const data = encoder.encode(plaintext);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const key = await genAES(password, salt);
  
    const ciphertext = await crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv: iv
      },
      key,
      data
    );
  
    // Объединение salt, iv и ciphertext в одном ArrayBuffer
    const combined = new Uint8Array(16 + 12 + ciphertext.byteLength);
    combined.set(salt);
    combined.set(iv, 16);
    combined.set(new Uint8Array(ciphertext), 16 + 12);
  
    cl('Шифрование окончено');
    return btoa(String.fromCharCode(...combined));
  } catch (error) {
    cl({'Catch в encrypt':error});
    throw(error);
  }
  
}
*/


async function decrypt(t, e = password) {
  try {
    const n = new Uint8Array(atob(t).split("").map(e => e.charCodeAt(0)));
    const a = n.slice(0, 16);
    const r = n.slice(16, 28);
    const s = n.slice(28);
    const o = await genAES(e, a);
    const i = await crypto.subtle.decrypt({name: "AES-GCM", iv: r}, o, s);
    return (new TextDecoder).decode(i);
  } catch (error) {
    cl({"catch в decrypt": error});
    throw(error);
  }
}


async function genAES(e, t) {
  const n = (new TextEncoder).encode(e);
  const a = await crypto.subtle.importKey("raw", n, "PBKDF2", false, ["deriveKey"]);
  return await crypto.subtle.deriveKey({name: "PBKDF2", salt: t, iterations: 1, hash: "SHA-256"}, a, {name: "AES-GCM", length: 256}, true, ["encrypt", "decrypt"]);
}

const limitCryptoApi = async (maxsize) => {
  cl(maxsize);
  cl('Проверка максимального размера файла');
    let currentLength = 100000;
    let maximumLength = 0;

    try {
        loadanim(20);
        if (maxsize < 1000000) {
          try {
            let segment = 'a'.repeat(maxsize);
            const encryptedText = await encrypt(segment);
            loadanim(40);
            cl(`Размер файла, меньше максимального`);
            return maxsize;
          } catch (e) {
            cl({'catch в limitCryptoApi 1':e});
            loadanim(50);
          }
        }
        

        loadanim(60);
        while (true) {
            // Увеличиваем длину для следующей итерации
            currentLength += 10000; // Добавляем 10 КБ

            // Генерируем строку заданной длины
            let segment = 'a'.repeat(currentLength);
            
            // Шифруем строку
            const encryptedText = await encrypt(segment);
            //cl(encryptedText);

            maximumLength = currentLength;
        }

    } catch (error) {
      loadanim(70);
      cl({'catch в limitCryptoApi 2':error, 'Максимальный размер':maximumLength});
      return maximumLength;
    }
};


function base2file(name, base) {
  // Ваша base64-строка
  const base64String = base; // Здесь ваша строка
  
  // Разделяем строку по запятой, чтобы получить тип данных и саму base64-строку
  const parts = base64String.split(',');
  const contentType = parts[0].split(':')[1];
  const rawBase64 = parts[1];
  
  // Декодируем base64 в бинарные данные
  const decodedData = atob(rawBase64);
  
  // Преобразуем бинарные данные в массив байт
  const byteArray = new Uint8Array(decodedData.length);
  for (let i = 0; i < decodedData.length; i++) {
    byteArray[i] = decodedData.charCodeAt(i);
  }
  
  // Создаем Blob объект
  const blob = new Blob([byteArray], { type: contentType });
  
  // Теперь blob можно использовать, например, для создания объекта File
  const file = new File([blob], name, { type: contentType });
  
  // Теперь у вас есть файл "file" для использования по вашему усмотрению
  // Создаем ссылку
  const downloadLink = document.createElement('a');
  downloadLink.href = URL.createObjectURL(file);
  downloadLink.download = file.name;
  
  // Добавляем ссылку к документу
  document.body.appendChild(downloadLink);
  
  // Запускаем скачивание
  downloadLink.click();
  
  // Удаляем ссылку из документа (необязательно, но хорошая практика)
  document.body.removeChild(downloadLink);
}
</script>
